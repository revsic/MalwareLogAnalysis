import argparse
import os
import re
from multiprocessing import Process, Queue, Lock

from sqlalchemy import Column, ForeignKey, Integer, String, create_engine
from sqlalchemy.orm import relationship, sessionmaker
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()


class Malware(Base):
    """Malware database.
    Attributes:
        name: name of the db.
    Static Member:
        __tablename__: str, name of the table.
        id: Column, integer, primary key.
        name: Column, name of the malware.
        branches: Reference of the db `Branch`.
    """
    __tablename__ = 'malware'
    id = Column(Integer, primary_key=True)
    name = Column(String, nullable=False)

    branches = relationship('Branch', backref='malware')

    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return "<Malware(id=%s, name='%s')>" % (self.id, self.name)


class Branch(Base):
    """Branch database.
    Attributes:
        malware_id: int, id of the malware.
        order: int, order of the branch data.
        src_addr: int, source address.
        dst_addr: int, destination address.
        dll: str, dll name where destination address exist.
        symbol: str, api symbol of the destination address.
    """
    __tablename__ = 'branch'
    id = Column(Integer, primary_key=True)
    order = Column(Integer, nullable=False)

    src_addr = Column(Integer, nullable=False)
    dst_addr = Column(Integer, nullable=False)

    dll = Column(String)
    symbol = Column(String)

    malware_id = Column(Integer, ForeignKey('malware.id'), nullable=False)

    def __init__(self, mal, order, src_addr, dst_addr, dll, symbol):
        self.malware_id = mal
        self.order = order

        self.src_addr = src_addr
        self.dst_addr = dst_addr

        self.dll = dll
        self.symbol = symbol

    def __repr__(self):
        return "<Branch(id=%s, mal_id=%s, src=%s, dst=%s, dll=%s, name=%s)>" \
            % (self.id, self.malware_id, self.src_addr, self.dst_addr, self.dll, self.symbol)


def init_db(db_url='sqlite:///data/malware.db'):
    """Initialize database.
    Args:
        db_url: str, url of the database.
    """
    engine = create_engine(db_url)
    Base.metadata.create_all(engine)


def writer(proc_id, log_dir, db_url, debug, lock, queue, output):
    """Log writer.
    Args:
        proc_id: int, process id.
        log_dir: str, directory of the log files.
        db_url: str, url of the database.
        debug: bool, debug flag.
        lock: Lock, lock for writing database synchronously.
        queue: Queue, input queue.
        output: Queue, output queue.
    """
    # create database engine
    engine = create_engine(db_url)
    # generate session
    Session = sessionmaker()
    Session.configure(bind=engine)

    sess = Session()

    while True:
        # get signal
        log = queue.get()
        # if signal end of loop
        if log is None:
            # commit data to session
            lock.acquire()
            sess.commit()
            lock.release()
            # put signal end of process
            output.put(proc_id)
            break

        if debug:
            # write log
            print('proc %d : log %s' % (proc_id, log))

        with open(os.path.join(log_dir, log)) as f:
            # read name of the binary.
            name = f.readline()
            name = re.findall(r'\[(.*)\]', name)[0]
            # create malware row
            mal = Malware(name)
            sess.add(mal)
            # commit to session
            lock.acquire()
            sess.commit()
            lock.release()

            i = 0
            ind = None
            for branch in f.readlines():
                i += 1

                # if branch repeated
                if branch.startswith('++'):
                    # add previous branch
                    sess.add(ind)
                else:
                    # split with seperator
                    tmp = branch[1:-1].split(',')
                    # if api info exist
                    if len(tmp) == 4:
                        src, dst, dll, sym = tmp
                    elif len(tmp) == 3:
                        src, dst, dll = tmp
                        sym = ''
                    # convert address to integer
                    src = int(src, 16)
                    dst = int(dst, 16)
                    # generate branch data
                    ind = Branch(mal.id, i, src, dst, dll, sym)
                    # add branch
                    sess.add(ind)


def log_writer(proc_cnt=10,
               log_dir='./log/malware',
               db_url='sqlite:///data/malware.db',
               debug=False):
    """Write log to the database.
    Args:
        proc_cnt: int, number of the process for parallel writing.
        log_dir: str, directory of the log files.
        db_url: str, url of the database.
        debug: bool, debug flag.
    """
    lock = Lock()
    queue = Queue()
    output = Queue()
    # create process
    for i in range(proc_cnt):
        proc = Process(target=writer, args=(i, log_dir, db_url, debug, lock, queue, output))
        proc.daemon = True
        proc.start()
    # put log files
    for log in os.listdir(log_dir):
        queue.put(log)
    # put end of loop
    for i in range(proc_cnt):
        queue.put(None)

    end = 0
    target_sum = sum(range(proc_cnt))
    # until child process end
    while end != target_sum:
        end += output.get()


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--proc_cnt', type=int, default=10)
    parser.add_argument('--log_dir', default='./log/malware')
    parser.add_argument('--db_url', default='sqlite:///data/malware.db')
    parser.add_argument('--debug', action='store_true', default=False)
    args = parser.parse_args()

    init_db(args.db_url)
    log_writer(args.proc_cnt, args.log_dir, args.db_url, args.debug)
